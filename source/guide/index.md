title: Начало работы
type: guide
order: 2
---

## Вступление

Vue.js – библиотека для построения интерактивных веб-интерфейсов.

Технически Vue.js фокусируется на слое [Модель Представления](#ViewModel) (ViewModel) паттерна MVVM. Данный слой объединяет [Представление](#View) и [Модель](#Model) с помощью двусторонней привязки данных. Манипуляции с DOM абстрагируются при помощи [Директив](#Directives) и [Фильтров](#Filters).

Целью библиотеки является предоставление всех преимуществ реактивной привязки данных в совокупности с компонуемыми компонентами представления и максимально простым API. Это не огромный фреймворк – Vue.js спроектирован чтобы быть максимально простым слоем представления. Вы можете использовать его отдельно для быстрого прототипирования или совмещать с другими библиотеками, для создания собственного стека разработки. Также он идеально подходит для сервисов заменяющих бэкенд, таких как Firebase.

На API Vue.js в значительной степени повлияли [AngularJS], [KnockoutJS], [Ractive.js] и [Rivets.js]. Несмотря на сходства, я считаю, что Vue.js предоставляет хорошую альтернативу существующим библиотекам, путём нахождения золотой середины между простотой и функциональностью.

Даже если вы уже встречались с некоторыми из следующих терминов, рекомендуется ознакомиться с их определениями, так как их значение может различаться в контексте Vue.js.

## Основные понятия

### Модель Представления

Объект который производит синхронизацию между Моделью и Представлением. В Vue.js каждый экземпляр является Моделью Представления. Экземпляры создаются с помощью конструктора `Vue` или его подклассов:

```js
var vm = new Vue({ /* options */ })
```

Это основной объект с которым вы будете осуществлять взаимодействие при разработки на Vue.js. Подробная документация доступна в разделе [Конструктор Vue](/api/).

### Представление

DOM, которым управляет экземпляр Vue.

```js
vm.$el // The View
```

Vue.js использует шаблонизацию основанную на DOM. Каждый экземпляр Vue привязан к соответствующему DOM элементу. При создании экземпляра Vue, происходит рекурсивный обход всех дочерних узлов корневого элемента, и устанавливаются требуемые связи между данными и представлением. После того, как Представление было скомпилировано, оно начинает реагировать на изменение данных.

При использовании Vue.js, вам редко потребуется работать с DOM напрямую, исключая пользовательские директивы (см. далее). При изменении данных, будет автоматически запущенно обновление представления. Обновление затрагивает только конечные узлы с текстом. Также обновления группируются и выполняются асинхронно для увеличения производительности.

### Модель

Слегка изменённые объекты JavaScript.

```js
vm.$data // The Model
```

В Vue.Js, модели представляют собой обычные объекты JavaScript. Вы можете управлять их свойствами. Экземпляр Vue, который контролирует данный объект, будет информирован об этих изменениях. Для достижения подобного поведения Vue.js конвертирует свойства объектов в геттеры и сеттеры. В этом случае, не требуется "грязная" проверка изменений значений, и вам не нужно как-либо сообщать Vue о необходимости обновить Представление. Всякий раз, когда данные изменяются, Представление обновляется на следующем кадре.

Экземпляры Vue проксируют все свойства объектов, за которыми наблюдают. Когда объект `{ a: 1 }` попадает под наблюдение экземпляра Vue `wm`, оба свойства `vm.$data.a` и `vm.a` возвращают одинаковое значение. Изменение `vm.a = 2` приведёт к изменению `vm.$data`.

Объекты изменяются на месте. Так изменение объекта по ссылке будет иметь тот же результат, что и изменение `vm.$data`. Это позволяет устанавливать наблюдение за одними и теми же данными из разных экземпляров Vue. В больших приложениях рекомендуется рассматривать экземпляры Vue, как простое описание Представления, и отделять логику, оперирующую с данными в отдельный дискретный слой.

Существует недостаток подобной организации работы с объектами. После инициализации Vue.js не имеет возможности обнаружить добавленные или удалённые свойства. Чтобы обойти данное ограничение, каждый объект, который находится под наблюдением, снабжается методами `$add`, `$set` и `$delete`.

### Директивы

Снабжённые специальным префиксом атрибуты HTML, которые указывают Vue.js выполнить какие-либо действия с элементом DOM.

```html
<div v-text="message"></div>
```

В данном случае элемент div содержит директиву `v-text`, значение которой `message`. Это указывает Vue.js, что требуется синхронизировать текст внутри тега div со свойством `message` экземпляра Vue.

Директивы могут инкапсулировать различные действия с DOM. Например директива `v-attr` управляет атрибутами элемента, `v-repeat` клонирует элемент, в соответствии со значениями массива, `v-on` прикрепляет обработчики собитий... мы подробно остановимся на директивах позже.

### Биндинги Mustache 

Вы можете также использовать биндинги в стиле mustache, для текста и атрибутов элементов. Они будут транслированы в `v-text` и `v-attr` директивы. К примеру:

```html
<div id="person-{{id}}">Hello {{name}}!</div>
```

Несмотря на то, что это достаточно удобно, есть несколько вещей, которые вы должны знать:

<p class="tip">Атрибут `src` элемента `<image>` создаёт HTTP запрос, при наличии значения. В этом случае результатом запроса будет ошибка 404, так как запрос отправится до компиляции экземпляра Vue. Для данного атрибута желательно использовать `v-attr`.</p>

<p class="tip">Internet Explorer удаляет некорректные атрибуты `style` при разборе HTML, всегда используйте `v-style` при использовании данного атрибута если необходимо поддерживать IE.</p>

Вы можете использовать тройные фигурные скобки для вывода HTML. В данном случае будет использована директива `v-html`:

``` html
{{{ safeHTMLString }}}
```

Тем не менее, это может открыть двери для потенциальных XSS атак, поэтому предполагается, что вы используйте их, только когда абсолютно уверены, что контент безопасен, или передаёте его через фильтр, который уберёт ненадёжный HTML.

Наконец, вы можете добавить `*` к биндингам, чтобы выполнить интерпретацию один раз, и не реагировать на изменение данных:

``` html
{{* onlyOnce }}
```

### Фильтры

Фильтры представляют собой функции, которые используются для обработки сырых данных до обновления Представления. Они обозначаются вертикальной чертой ("|") в директивах или биндингах:

```html
<div>{{message | capitalize}}</div>
```

Теперь, перед тем как внутри элемента div обновится текст, значение `message` будет сначала пропущено через функцию `capitalize`. Более подробно об этом можно прочитать в разделе [Фильтры в деталях](/guide/filters.html).

### Компоненты

В Vue.js, каждый компонент является экземпляром Vue. Компоненты образуют вложенную древовидную иерархию, описывающую интерфейс вашего приложения. Они могут быть созданы с помощью конструктора, который возвращает метод `Vue.extend`, но более декларативным подходом является регистрация их с помощью метода `Vue.component(id, constructor)`. После регистрации, они доступны в шаблонах, в виде пользовательских элементов:

``` html
<my-component>
  <!-- internals handled by my-component -->
</my-component>
```

Этот простой механизм позволяет переиспользовать и совмещать экземпляры Vue подобно [Веб Компонентам](http://www.w3.org/TR/components-intro/), без жёстких ограничений на версию браузера или огромных полифилов. В результате разделения приложения на небольшие компоненты получается хорошо структурированный и легко поддерживаемый код. Больше деталей о реализации компонентов вы можете найти в разделе [Система Компонентов](/guide/components.html).

## Небольшой пример

``` html
<div id="demo">
  <h1>{{title | uppercase}}</h1>
  <ul>
    <li
      v-repeat="todos"
      v-on="click: done = !done"
      class="{{done ? 'done' : ''}}">
      {{content}}
    </li>
  </ul>
</div>
```

``` js
var demo = new Vue({
  el: '#demo',
  data: {
    title: 'todos',
    todos: [
      {
        done: true,
        content: 'Learn JavaScript'
      },
      {
        done: false,
        content: 'Learn Vue.js'
      }
    ]
  }
})
```

**Result**

<div id="demo"><h1>&#123;&#123;title | uppercase&#125;&#125;</h1><ul><li v-repeat="todos" v-on="click: done = !done" class="&#123;&#123;done ? 'done' : ''&#125;&#125;">&#123;&#123;content&#125;&#125;</li></ul></div>
<script>
var demo = new Vue({
  el: '#demo',
  data: {
    title: 'todos',
    todos: [
      {
        done: true,
        content: 'Learn JavaScript'
      },
      {
        done: false,
        content: 'Learn Vue.js'
      }
    ]
  }
})
</script>

Также доступен на [jsfiddle](http://jsfiddle.net/yyx990803/yMv7y/).

Вы можете кликнуть на задачу чтобы переключить статус, или открыть консоль разработчика и поиграть с объектом `demo` – для примера, изменить `demo.title` добавить новый элемент в `demo.todos` или переключить статус задачи `done`.

Вероятно, у вас остались некоторые вопросы – не беспокойтесь, мы рассмотрим их в ближайшее время.

Далее: [Директивы в деталях](/guide/directives.html).

[AngularJS]: http://angularjs.org
[KnockoutJS]: http://knockoutjs.com
[Ractive.js]: http://ractivejs.org
[Rivets.js]: http://www.rivetsjs.com
