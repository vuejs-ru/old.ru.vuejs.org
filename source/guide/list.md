title: Отображение списков
type: guide
order: 5
---

Вы можете использовать директиву `v-repeat` для многократного вывода шаблона с массивом объектов в качестве модели представления. Для каждого объекта в массиве, директива создаст дочерний экземпляр Vue, используя объект в качестве свойства `$data`. Экземпляры наследуют данные родителя, таким образом, вы можете осуществлять доступ к данным как текущего так и родительского экземпляра. В дополнение, вы получаете доступ к свойству `$index`, которое является индексом текущего объекта в массиве.

**Пример:**

``` html
<ul id="demo">
  <li v-repeat="items" class="item-{{$index}}">
    {{$index}} - {{parentMsg}} {{childMsg}}
  </li>
</ul>
```

``` js
var demo = new Vue({
  el: '#demo',
  data: {
    parentMsg: 'Hello',
    items: [
      { childMsg: 'Foo' },
      { childMsg: 'Bar' }
    ]
  }
})
```

**Результат:**

<ul id="demo"><li v-repeat="items" class="item-{&#123;$index&#125;}">{&#123;$index&#125;} - {&#123;parentMsg&#125;} {&#123;childMsg&#125;}</li></ul>
<script>
var demo = new Vue({
  el: '#demo',
  data: {
    parentMsg: 'Hello',
    items: [
      { childMsg: 'Foo' },
      { childMsg: 'Bar' }
    ]
  }
})
</script>

## Использование с Блоками

Иногда может потребоваться вывести несколько узлов – в этом случае, вы можете использовать тег `<template>`, и обернуть в него нужный блок. Тег `<template>` в данном случае служит для семантической обёртки блока. Например:

``` html
<ul>
  <template v-repeat="list">
    <li>{{msg}}</li>
    <li class="divider"></li>
  </template>
</ul>
```

## Массивы Примитивных Типов

Для массивов содержащих примитивные значения, вы можете получить доступ к значению с помощью `$value`:

``` html
<ul id="tags">
  <li v-repeat="tags">
    {{$value}}
  </li>
</ul>
```

``` js
new Vue({
  el: '#tags',
  data: {
    tags: ['JavaScript', 'MVVM', 'Vue.js']
  }
})
```

**Результат:**
<ul id="tags" class="demo"><li v-repeat="tags">{&#123;$value&#125;}</li></ul>
<script>
new Vue({
  el: '#tags',
  data: {
    tags: ['JavaScript', 'MVVM', 'Vue.js']
  }
})
</script>

## Использование Идентификатора

Иногда требуется получить явный доступ к переменной вместо использования родительского контекста. Вы можете добиться подобного поведения, предоставив идентификатор текущего элемента в качестве аргумента директивы `v-repeat` следующим образом:

``` html
<ul id="users">
  <!-- think of this as "for each user in users" -->
  <li v-repeat="user: users">
    {{user.name}} - {{user.email}}
  </li>
</ul>
```

``` js
new Vue({
  el: '#users',
  data: {
    users: [
      { name: 'Foo Bar', email: 'foo@bar.com' },
      { name: 'John Doh', email: 'john@doh.com' }
    ]
  }
})
```

**Результат:**
<ul id="users" class="demo"><li v-repeat="user: users">{&#123;user.name&#125;} - {&#123;user.email&#125;}</li></ul>
<script>
new Vue({
  el: '#users',
  data: {
    users: [
      { name: 'Foo Bar', email: 'foo@bar.com' },
      { name: 'John Doh', email: 'john@doh.com' }
    ]
  }
})
</script>

<p class="tip">Использование идентификатора вместе с `v-repeat` положительно влияет на читабельность шаблонов и производительность.</p>

## Модифицирующие методы

Vue.js перехватывает модифицирующие методы массива который находится под наблюдением (`push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()` и `reverse()`), таким образом они также будут вызывать обновления Представления.

``` js
// DOM представление будет обновлено
demo.items.unshift({ childMsg: 'Baz' })
demo.items.pop()
```

## Дополнительные Методы

Vue.js снабжает массивы двумя удобными методами: `$set()` и `$remove()`.

Вы должны избегать устанавливать значения элементов массива по индексу, так как эти изменения не будут подхваченны Vue.js. Вместо этого используйте дополнительный метод `$set()`:

``` js
// тоже что и `demo.items[0] = ...` но будет выполнено обновление
demo.items.$set(0, { childMsg: 'Changed!'})
```

`$remove()` является синтаксическим сахаром для метода `splice()`. Он удаляет элемент с заданным индексом. Если аргумент не является числом, `$remove()` удалит первое вхождение найденное в массиве.

``` js
// удалить элемент с индексом 0
demo.items.$remove(0)
```

## Замена Массива

Когда вы используете методы, которые не вызывают изменение переменной, такие как `filter()`, `concat()` или `slice()`, возвращаемый массив будет другим экземпляром. В таком случае, вы можете просто заменить старый массив новым:

``` js
demo.items = demo.items.filter(function (item) {
  return item.childMsg.match(/Hello/)
})
```
Можно подумать, что данное действие уничтожит текущий DOM и построит новый. Но не волнуйтесь – Vue.js распознает элементы массива, которые уже были привязаны к экземплярам Vue и будет использовать их если это возможно.

## Использование `track-by`

В некоторых случаях, вам может понадобиться заменить текущий массив массивом с абсолютно другими объектами, например после вызова метода API. Поскольку по-умолчанию `v-repeat` определяет возможность переиспользования уже имеющихся экземпляров и их DOM элементов, это может вызвать полное перепостроение списка элементов. Но если каждый из объектов массива имеет уникальный идентификатор, вы можете использовать `track-by` чтобы подсказать Vue.js какие из этих элементов можно использовать повторно.

К примеру, если имеется массив:

``` js
{
  items: [
    { _uid: '88f869d', ... },
    { _uid: '7496c10', ... }
  ]
}
```
Вы можете использовать `track-by` так:

``` html
<div v-repeat="items" track-by="_uid">
  <!-- content -->
</div>
```

Позже, когда вы замените массив `items` на новый, и Vue.js натолкнётся на объект с `_uid: '88f869d'`, будет использован старый экземпляр Vue для этого объекта с таким же `_uid`.

Если объекты не имеют уникального ключа, вы можете использовать `track-by="$index"`. Такое применение требует осторожности, потому что вместо перемещения дочерних экземпляров и элементов DOM, Vue будет просто переиспользовать их в таком порядке, в каком они были созданы. Избегайте использования `track-by="$index"` в двух случаях: когда требуется вывести блок содержащий элементы формы; или когда вы используете для вывода компоненты с изменяемым состоянием и передачей данных из перебираемого массива.

<p class="tip">Правильное использование `track-by` может значительно увеличить производительность при повторном рендеринге больших списков `v-repeat` с использованием новых данных.</p>

## Итерация по Свойствам Объекта

Вы можете также использовать `v-repeat` для перебора свойств объекта. Каждый экземпляр в таком случае будет иметь специальное свойство `$key`. Для простых значений, вы, как и раньше, можете использовать `$value` для того чтобы получить значение ключа.

``` html
<ul id="repeat-object">
  <li v-repeat="primitiveValues">{{$key}} : {{$value}}</li>
  <li>===</li>
  <li v-repeat="objectValues">{{$key}} : {{msg}}</li>
</ul>
```

``` js
new Vue({
  el: '#repeat-object',
  data: {
    primitiveValues: {
      FirstName: 'John',
      LastName: 'Doe',
      Age: 30
    },
    objectValues: {
      one: {
        msg: 'Hello'
      },
      two: {
        msg: 'Bye'
      }
    }
  }
})
```

**Результат:**
<ul id="repeat-object" class="demo"><li v-repeat="primitiveValues">{&#123;$key&#125;} : {&#123;$value&#125;}</li><li>===</li><li v-repeat="objectValues">{&#123;$key&#125;} : {&#123;msg&#125;}</li></ul>
<script>
new Vue({
  el: '#repeat-object',
  data: {
    primitiveValues: {
      FirstName: 'John',
      LastName: 'Doe',
      Age: 30
    },
    objectValues: {
      one: {
        msg: 'Hello'
      },
      two: {
        msg: 'Bye'
      }
    }
  }
})
</script>

<p class="tip">В стандарте ECMAScript 5 нет способа отловить добавление или удаление свойство объекта. Для обхода этого ограничения объекты, находящиеся под наблюдением Vue, наделены тремя методами: `$add(key, value)`, `$set(key, value)` и `$delete(key)`. Данные методы могут быть использованы для добавления / удаления свойств объектов с последующим изменением Представления. Разница между `$add` и `$set` заключается в том, что `$add` добавит ключ только в том случае, когда его не существует, так вызов `obj.$add(key)` не может изменить текущее значение ключа на `undefined`.</p>

## Итерация по Интервалу

`v-repeat` также может принимать целое число в качестве аргумента. В таком случае, шаблон будет выведен указанное число раз.

``` html
<div id="range">
    <div v-repeat="val">Hi! {{$index}}</div>
</div>
```

``` js
new Vue({
  el: '#range',
  data: {
    val: 3
  }
});
```
**Результат:**
<ul id="range" class="demo"><li v-repeat="val">Hi! {&#123;$index&#125;}</li></ul>
<script>
new Vue({
  el: '#range',
  data: { val: 3 }
});
</script>

## Фильтры Массивов

Иногда требуется вывести отфильтрованный или отсортированный массив, не производя при этом изменений в оригинальном массиве. Vue предоставляет два встроенных фильтра для упрощения данной задачи: `filterBy` и `orderBy`. Смотрите [документацию](/api/filters.html#filterBy) для получения более подробной информации о них.

Далее: [Обработка Событий](/guide/events.html).
